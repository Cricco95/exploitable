% Terzo capitolo
\subsection{SQL Injection}
Per risolvere le due SQL Injection è stata utilizzata la funzione \texttt{mysqli\_real\_escape\_string} che esegue l'escape automatico dei caratteri speciali del linguaggio SQL. In questo modo apici e cancelletti vengono inseriti all'interno della query e non interpretati come caratteri speciali. Qui di seguito è possibile verificare le modifiche effettuate sulla pagina di login. Prima del fix:

\begin{lstlisting}
$username = $_POST['username'];
$password = hash('sha256', $_POST['password']);
\end{lstlisting}

Dopo il fix:

\begin{lstlisting}
$username = $mysqli->real_escape_string($_POST['username']);
$password = hash('sha256', $mysqli->real_escape_string($_POST['password']));
\end{lstlisting}

In questo modo, i parametri passati tramite POST allo script PHP vengono innanzitutto sanitizzati, e poi assegnati alle variabili corrispondenti risolvendo così la SQL Injection.

La stessa tecnica è stata implementata nella barra di ricerca della dashboard:

\begin{lstlisting}
$search = $mysqli->real_escape_string($_GET['search']);
\end{lstlisting}

Un altro modo per risolvere le SQLi è quello di utilizzare i cosiddetti "prepared statement", che eseguono la query controllando in modo automatico l'input dell'utente. Un tipico esempio di prepared statement è il seguente:

\begin{lstlisting}
$stmt = $conn->prepare("INSERT INTO MyGuests (firstname, lastname, email) VALUES (?, ?, ?)");
$stmt->bind_param("sss", $firstname, $lastname, $email);
$firstname = "John";
$lastname = "Doe";
$email = "john@example.com";
$stmt->execute();
$stmt->close();
\end{lstlisting}

Come è possibile notare, i parametri vengono assegnati a delle variabili tramite la funzione \texttt{bind\_param}, successivamente vengono impostati i valori delle variabili, ed infine si esegue lo statement o query.

\subsection{Remote Code Execution}
Per risolvere la RCE è stato applicato un filtro sul parametro in input tramite una regular expression, o più brevemente regex. Quello che vediamo ora è il codice che filtra l'input, eliminando tutti i caratteri ";":

\begin{lstlisting}
$path = $_POST['path'];
$path = preg_replace('/;', '', $path);
\end{lstlisting}

Questa regex elimina però solo parzialmente la RCE, perché è possibile comunque sfruttarla per eseguire codice arbitrario nella macchina. Infatti oltre al classico ";", per eseguire comandi concatenati in Unix è possibile utilizzare "\&\&" e "|". Dunque è stata modificata l'espressione regolare nel seguente modo:

\begin{lstlisting}
$path = $_POST['path'];
$path = preg_replace('/[;&|]', '', $path);
\end{lstlisting}

Risulta quindi ora impossibile sfruttare la vulnerabilità.

\subsection{Cross Site Scripting}
Per arginare il problema dell'esecuzione di script nella pagina web tramite il campo di ricerca della dashboard, è stata utilizzata la funzione \texttt{htmlentities} di PHP per eseguire l'escape dei caratteri HTML "pericolosi", come ad esempio \texttt{<} e \texttt{>}. 

\begin{lstlisting}
$search = htmlentities($search);
\end{lstlisting}

In questo modo i caratteri come \texttt{<} e \texttt{>} vengono codificati rispettivamente in \texttt{\&lt;} e \texttt{\&gt;} che impediscono dunque l'esecuzione, in questo caso, di script javascript in quanto il tag \texttt{<script>} non viene riconosciuto.

\subsection{Buffer Overflow}
Il buffer overflow è stato ottenuto utilizzando una funzione vulnerabile \texttt{gets()} ancora presente nel linguaggio C. La prima cosa da fare per sistemare il problema è utilizzare la funzione \texttt{fgets()}, che non soffre di problemi di buffer overflow e successivamente controllare che il programma venga compilato con le protezioni contro l'esecuzione di codice nello stack e con l'utilizzo dei canary; infine è sempre bene controllare che l'ASLR (Address Space Layout Randomization) sia attivo nel sistema.